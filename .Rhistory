#   transition: faster
# css: 'scrollable_slides.css'
# runtime: shiny
# https://bookdown.org/yihui/rmarkdown/ioslides-presentation.html
# The following single character keyboard shortcuts enable alternate display modes:
#
# 'f': enable fullscreen mode
#
# 'w': toggle widescreen mode
#
# 'o': enable overview mode
#
# 'h': enable code highlight mode
#
# 'p': show presenter notes
---
```{r}
```
#
```{r}
# devtools::install_github(repo = "luka3117/JcPackage/OsakaUniv2020")
# 使用package
suppressMessages(library(readxl))
suppressMessages(library(dplyr))
suppressMessages(library(data.table))
suppressMessages(library(kableExtra))
suppressMessages(library(curl))
suppressMessages(library(tidyverse))
suppressMessages(library(plotly))
suppressMessages(library(ggrepel))
load("../ScreenEnd.RData")
```
# regression{.tabset .tabset-fade .tabset-pills}
- only the followings are valid obj
- d , var, pref_id
- d_f_merge_X, d_m_merge_X, y_f , y_m
- LE_d_f_final, HLE_d_f_final, LE_d_m_final, HLE_d_m_final
<!-- ```{r child="ref1.Rmd"} -->
<!-- ``` -->
## regression `LE_d_f_final`: 女性、平均寿命
```{r}
# -----------------
# Q1:Do the final regression and interprete : with 4 data
# -----------------
# ----------------- ----------------- ----------------- -----------------
#  _____ _             _   _     __  __
# |  ___(_)_ __   __ _| | | |   |  \/  |
# | |_  | | '_ \ / _` | | | |   | |\/| |
# |  _| | | | | | (_| | | | |___| |  | |
# |_|   |_|_| |_|\__,_|_| |_____|_|  |_|
# ----------------- ----------------- ----------------- -----------------
options(digits = 5)              # Modify global options
lm(LE_2015~. , data = LE_d_f_final) %>%
broom::tidy() %>%
left_join(var, by=c("term"="var_name_Eng")) %>%
select(term, var_name_Jpn, everything(), -id,- address, -std.error, -columm_letter ) %>% DT::datatable() %>% DT::formatRound(columns=c('estimate', 'statistic', "p.value"), digits=3)
```
ls()
load("../ScreenEnd.RData")
load("ScreenEnd.RData")
ls()
lm(LE_2015~. , data = LE_d_f_final) %>%
broom::tidy() %>%
left_join(var, by=c("term"="var_name_Eng")) %>%
select(term, var_name_Jpn, everything(), -id,- address, -std.error, -columm_letter ) %>% DT::datatable() %>% DT::formatRound(columns=c('estimate', 'statistic', "p.value"), digits=3)
aa=lm(LE_2015~. , data = LE_d_f_final)
aa$model
aa$model %>% tbl_df()
aa$model %>% tbl_df() %>% scale()
aa$model %>% scale()%>% tbl_df()
aa$model %>% scale()%>% tbl_df() %>% hist()
aa$model %>% scale()%>% tbl_df() %>% map(hist)
system("open .")
devtools::install_github(repo = "luka3117/JcPackage/tree/master/zemi")
devtools::install_github(repo = "luka3117/JcPackage/zemi")
devtools::install_github(repo = "luka3117/JcPackage/zemi")
devtools::install_github(repo = "luka3117/JcPackage/OsakaUniv2020")
system("open .")
FS <- 160                     # サンプリング周波数 FS=160[Hz]
DT <- 1/FS                    # 標本間隔 DT=1/160=0.00625[s]
N <- 16                       # データ数 N=16
i <- 0:(N-1)                  # 添字(index)の範囲 i
##### 振幅1，10[Hz]の正弦波(siga)
siga <- sin(2*pi*10*DT*i)
plot(siga)
##### 振幅0.25，30[Hz]の余弦波(sigb)
sigb <- 0.25*cos(2*pi*30*DT*i)
plot(DT*i, sigb, xlab='Time', type='o')    # plotして確認
##### 振幅1，10[Hz]の正弦波(siga)
siga <- sin(2*pi*10*DT*i)
plot(siga)
plot(DT*i, siga, xlab='Time', type='o')    # plotして確認
##### 振幅0.25，30[Hz]の余弦波(sigb)
sigb <- 0.25*cos(2*pi*30*DT*i)
plot(DT*i, sigb, xlab='Time', type='o')    # plotして確認
##### 合成波(sig)
sig <- siga + sigb
plot(DT*i, sig, xlab='Time', type='o')     # plotして確認
fft(sig)
sigb
spec <- fft(sig)/N                # FFTの実行
plot(abs(spec),type='h')         # 絶対値のスペクトル
spec <- fft(sig)/N                # FFTの実行
spec
suppressMessages(library(tidyverse))
spec %>% DT::datatable()
spec %>% tbl_df() %>%
DT::datatable()
spec
spec %>% tbl_df() %>% round(2)
# FFTの実行
plot(abs(spec),type='h')         # 絶対値のスペクトル
plot(abs(spec),type='h')         # 絶対値のスペクトル
plot(Re(spec),type='h')          # 実部値のスペクトル
plot(Im(spec),type='h')          # 虚部値のスペクトル
# FFTの実行
plot(abs(spec),type='h')         # 絶対値のスペクトル
plot(Re(spec),type='h')          # 実部値のスペクトル
plot(Im(spec),type='h')          # 虚部値のスペクトル
plot(Re(spec),type='h',col='blue', ylab='', ylim=c(-1,1))
par(new=T)                       # グラフを上書き可能モードにする
plot(Im(spec),type='h',col='red', ylab='Spectrum Xk', ylim=c(-1,1))
spec
spec %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(x = spec))+
theme_bw(base_family = "HiraKakuProN-W3")
spec %>% data_frame() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(x = spec))+
theme_bw(base_family = "HiraKakuProN-W3")
spec
spec %>% data_frame()
spec %>% data_frame() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(x = .))+
theme_bw(base_family = "HiraKakuProN-W3")
spec
spec %>% enframe()
spec %>% enframe()
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(x = value))+
theme_bw(base_family = "HiraKakuProN-W3")
spec %>% enframe()
spec %>% enframe() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(x = value))+
theme_bw(base_family = "HiraKakuProN-W3")
spec %>% enframe() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(x = value))+geom_bar()
theme_bw(base_family = "HiraKakuProN-W3")
spec %>% enframe() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(x = value))+geom_bar()+
theme_bw(base_family = "HiraKakuProN-W3")
spec %>% enframe() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(y = value))+geom_bar()+
theme_bw(base_family = "HiraKakuProN-W3")
spec %>% enframe() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(y = value))+geom_point()
spec %>% enframe() %>%
spec %>% enframe()
source('~/.active-rstudio-document', echo=TRUE)
spec %>% enframe()
spec %>% enframe() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(y = value))+geom_point()
spec %>% enframe() %>%
# ggplot(aes(x = spec, group=cyl, col=cyl))+
ggplot(aes(x = value))+geom_point()
spec %>% enframe() %>% plot()
# FFTの実行
plot(abs(spec),type='h')         # 絶対値のスペクトル
plot(Re(spec),type='h')          # 実部値のスペクトル
plot(Im(spec),type='h')          # 虚部値のスペクトル
plot(Re(spec),type='h',col='blue', ylab='', ylim=c(-1,1))
par(new=T)                       # グラフを上書き可能モードにする
plot(Im(spec),type='h',col='red', ylab='Spectrum Xk', ylim=c(-1,1))
Im(spec)
0:(N-1)
N <- 16
x <- c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1)
x[9, 1]
x <- c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1) %>% enframe()
x[9, 1]
x
N <- 16
x <- read.table("rect.dat")
x <- c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1) %>% enframe() %>% select(vlaue)
x[9, 1]
x <- c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1) %>% enframe() %>% select(vlaue)
x
x <- c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1) %>% enframe() %>% select(-name)
x
x[9, 1]
fft(x[,1])/N
N <- 16
fft(x[,1])/N
y <- fft(x[,1])/N
y
N <- 16
x <- c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1) %>% enframe() %>% select(-name)
# FFTの実行，結果の実部だけを表示させてみる
y <- fft(x[,1])/N
x[,1])
x[,1]
x <- c(1,1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,-1,-1)
x
y <- fft(x)/N
y
df <- data.frame(ak=Re(y), bk=Im(y))
df$ak
df
library(tuneR)
# 音声データの信号解析
# 次に，実際の音声信号データを周波数解析してみます．
# Rには音声データ等を扱うパッケージも用意されています．
# ここでは，「tuneR(http://cran.r-project.org/web/packages/tuneR/)」というパッケージを使用します．パッケージがインストールされていない場合は，次のコマンドでインストールが可能です．
install.packages("tuneR")
library(tuneR)
library(tuneR)
library(tuneR)
beep <- sine(440)
play(beep)
setWavPlayer("/usr/bin/afplay")
# それを実際にプレーヤーを使って音を流してみます．
play(beep)
play(beep)
play(beep)
beep
play(beep)
play(beep)
play(beep)
beep <- sine(440)
plot(beep@left, type='l', xlab='Time', xlim=c(0,1000))
plot(beep@left, type='l', xlab='Time', xlim=c(0,1000))
plot(beep@left, type='l', xlab='Time', xlim=c(0,1000))
spec_beep <- fft(beep@left)
plot(abs(spec_beep),type='h', xlab='Frequency', xlim=c(0,1000))
spec_beep
spec_beep %>% dim()
spec_beep@left %>% dim()
spec_beep@left
beep@left
beep@left %>%class()
spec_beep <- fft(beep@left)
spec_beep
spec_beep %>% dim()
spec_beep %>% class()
spec_beep %>% length()
beep
beep@left
beep@left %>% length()
beep@left %>% class()
system("open .")
system("open .")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
zemi::USCrime
fa <- function(X) {
# created by jc lee
# ex : fa(zemi::USCrime )
# X <- zemi::USCrime
## --------------------------------------------------------------
# suppressMessages(library(dplyr))
# 1st argument X is dataframe
# X %>% DT::datatable()
# rownames(X) <- abbreviate(rownames(X))
## ---- warning=F------------------------------------------------
# n : number of data
# p : number of variables
# Z : scaled data
n <- nrow(X)
p <- ncol(X)
Z <- scale(X)
## --------------------------------------------------------------
# FA start
# OBS : observation score
# VAR : varibale score
svd.Z <- svd(Z/sqrt(n-1))
OBS <- svd.Z$u*sqrt(n-1)
# OBS %>% round(2) %>% as.data.frame() %>% tbl_df()
VAR <- svd.Z$v%*%diag(svd.Z$d)
# VAR %>% round(2)
# rownames(OBS) <- rownames(X)
# rownames(VAR) <- colnames(X)
## --------------------------------------------------------------
# OBS %>% as.data.frame() %>% tbl_df()
## --------------------------------------------------------------
# round(OBS,3) %>% head()
## --------------------------------------------------------------
# round(VAR,3)
# round(svd.Z$d^2,3)
#
## --------------------------------------------------------------
# biplot(OBS,VAR,cex=0.75,xlab="First Dimension",ylab="Second Dimension",xlim=c(-3,3),ylim=c(-3,3),main="Not Rotated")
## --------------------------------------------------------------
rotate <- function(VAR, theta)
{
G <- matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2)
VAR.rotate <- VAR[, 1:2] %*% G
return(VAR.rotate)
}
object.max <- function(theta)
{
D <- rotate(VAR[, 1:2], theta)
D2 <- D * D
norm <- apply(D2, 1, sum)
temp <- scale(D2 / norm, scale = F)
return(sum(temp * temp))
}
## --------------------------------------------------------------
theta.optim <- optimize(object.max, c(-pi,pi), maximum=T)
theta <- theta.optim$maximum
VAR.rotate <- rotate(VAR[,1:2],theta)
OBS.rotate <- rotate(OBS[,1:2],theta)
# c("optimum rotation in degrees"); round(theta*180/pi,1)
# c("rotated loading matrix"); round(VAR.rotate,3)
# c("rotated factor scores");
# round(OBS.rotate,3) %>% head()
res<-list(Z=Z,OBS=OBS,VAR=VAR,VAR.rotate=VAR.rotate,OBS.rotate=OBS.rotate)
return(res)
}
JcFA <- function(X) {
# created by jc lee
# ex : fa(zemi::USCrime )
# X <- zemi::USCrime
## --------------------------------------------------------------
# suppressMessages(library(dplyr))
# 1st argument X is dataframe
# X %>% DT::datatable()
# rownames(X) <- abbreviate(rownames(X))
## ---- warning=F------------------------------------------------
# n : number of data
# p : number of variables
# Z : scaled data
n <- nrow(X)
p <- ncol(X)
Z <- scale(X)
## --------------------------------------------------------------
# FA start
# OBS : observation score
# VAR : varibale score
svd.Z <- svd(Z/sqrt(n-1))
OBS <- svd.Z$u*sqrt(n-1)
# OBS %>% round(2) %>% as.data.frame() %>% tbl_df()
VAR <- svd.Z$v%*%diag(svd.Z$d)
# VAR %>% round(2)
# rownames(OBS) <- rownames(X)
# rownames(VAR) <- colnames(X)
## --------------------------------------------------------------
# OBS %>% as.data.frame() %>% tbl_df()
## --------------------------------------------------------------
# round(OBS,3) %>% head()
## --------------------------------------------------------------
# round(VAR,3)
# round(svd.Z$d^2,3)
#
## --------------------------------------------------------------
# biplot(OBS,VAR,cex=0.75,xlab="First Dimension",ylab="Second Dimension",xlim=c(-3,3),ylim=c(-3,3),main="Not Rotated")
## --------------------------------------------------------------
rotate <- function(VAR, theta)
{
G <- matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2)
VAR.rotate <- VAR[, 1:2] %*% G
return(VAR.rotate)
}
object.max <- function(theta)
{
D <- rotate(VAR[, 1:2], theta)
D2 <- D * D
norm <- apply(D2, 1, sum)
temp <- scale(D2 / norm, scale = F)
return(sum(temp * temp))
}
## --------------------------------------------------------------
theta.optim <- optimize(object.max, c(-pi,pi), maximum=T)
theta <- theta.optim$maximum
VAR.rotate <- rotate(VAR[,1:2],theta)
OBS.rotate <- rotate(OBS[,1:2],theta)
# c("optimum rotation in degrees"); round(theta*180/pi,1)
# c("rotated loading matrix"); round(VAR.rotate,3)
# c("rotated factor scores");
# round(OBS.rotate,3) %>% head()
res<-list(Z=Z,OBS=OBS,VAR=VAR,VAR.rotate=VAR.rotate,OBS.rotate=OBS.rotate)
return(res)
}
JcFA(zemi::USCrime)
aa=JcFA(zemi::USCrime)
aa$OBS
aa$VAR
biplot(aa$OBS,aa%VAR)
biplot(aa$OBS,aa$VAR)
biplot(aa$OBS,aa$VAR)
biplot(aa$OBS,aa$VAR)
load("../ScreenEnd.RData")
ls()
HLE_d_f_final
HLE_d_f_final[,-1]
HLE_d_f_final[,-1] %>% dim()
aa=JcFA(HLE_d_f_final[,-1])
aa$OBS
aa$VAR.rotate
aa$VAR.rotate
HLE_d_f_final %>% colnames()
res<-list(d=svd.Z$d, Z=Z,OBS=OBS,VAR=VAR,VAR.rotate=VAR.rotate,OBS.rotate=OBS.rotate)
JcFA <- function(X) {
# created by jc lee
# ex : fa(zemi::USCrime )
# X <- zemi::USCrime
## --------------------------------------------------------------
# suppressMessages(library(dplyr))
# 1st argument X is dataframe
# X %>% DT::datatable()
# rownames(X) <- abbreviate(rownames(X))
## ---- warning=F------------------------------------------------
# n : number of data
# p : number of variables
# Z : scaled data
n <- nrow(X)
p <- ncol(X)
Z <- scale(X)
## --------------------------------------------------------------
# FA start
# OBS : observation score
# VAR : varibale score
svd.Z <- svd(Z/sqrt(n-1))
OBS <- svd.Z$u*sqrt(n-1)
# OBS %>% round(2) %>% as.data.frame() %>% tbl_df()
VAR <- svd.Z$v%*%diag(svd.Z$d)
# VAR %>% round(2)
# rownames(OBS) <- rownames(X)
# rownames(VAR) <- colnames(X)
## --------------------------------------------------------------
# OBS %>% as.data.frame() %>% tbl_df()
## --------------------------------------------------------------
# round(OBS,3) %>% head()
## --------------------------------------------------------------
# round(VAR,3)
# round(svd.Z$d^2,3)
#
## --------------------------------------------------------------
# biplot(OBS,VAR,cex=0.75,xlab="First Dimension",ylab="Second Dimension",xlim=c(-3,3),ylim=c(-3,3),main="Not Rotated")
## --------------------------------------------------------------
rotate <- function(VAR, theta)
{
G <- matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2)
VAR.rotate <- VAR[, 1:2] %*% G
return(VAR.rotate)
}
object.max <- function(theta)
{
D <- rotate(VAR[, 1:2], theta)
D2 <- D * D
norm <- apply(D2, 1, sum)
temp <- scale(D2 / norm, scale = F)
return(sum(temp * temp))
}
## --------------------------------------------------------------
theta.optim <- optimize(object.max, c(-pi,pi), maximum=T)
theta <- theta.optim$maximum
VAR.rotate <- rotate(VAR[,1:2],theta)
OBS.rotate <- rotate(OBS[,1:2],theta)
# c("optimum rotation in degrees"); round(theta*180/pi,1)
# c("rotated loading matrix"); round(VAR.rotate,3)
# c("rotated factor scores");
# round(OBS.rotate,3) %>% head()
res<-list(d=svd.Z$d, Z=Z,OBS=OBS,VAR=VAR,VAR.rotate=VAR.rotate,OBS.rotate=OBS.rotate)
return(res)
}
aa=JcFA(HLE_d_f_final[,-1])
aa$d
aa$VAR
aa$VAR.rotate
aa$VAR.rotate[,c(1:2)]
aa$VAR.rotate[,c(1:2)]
aa$VAR[,c(1:2)]
aa$VAR.rotate
aa$VAR[,c(1:2)]
aa$VAR[,c(1:3)]
aa$VAR[,c(1:3)] %>% round(2)
aa$VAR.rotate[,c(1:2)]
aa$VAR.rotate
rownames(aa$VAR.rotate)<-colnames(HLE_d_f_final)
rownames(aa$VAR.rotate)<-colnames(HLE_d_f_final[-1])
aa$VAR.rotate
biplot(aa$VAR.rotate)
aa$VAR.rotate
plot(aa$VAR.rotate[1] )
plot(aa$VAR.rotate)
plot(aa$OBS.rotate,
aa$VAR.rotate)
aa$OBS.rotate
plot(aa$OBS.rotate,
aa$VAR.rotate)
plot(aa$OBS.rotate,
aa$VAR.rotate)
plot(aa$OBS.rotate,
aa$VAR.rotate)
devtools::install_github(repo = "luka3117/JcPackage/zemi")
devtools::install_github(repo = "luka3117/JcPackage/zemi")
devtools::install_github(repo = "luka3117/JcPackage/zemi")
devtools::install_github(repo = "luka3117/JcPackage/zemi", force = TRUE)
remove.packages("zemi")
devtools::install_github(repo = "luka3117/JcPackage/zemi", force = TRUE)
remove.packages("zemi")
remove.packages("zemi")
devtools::install_github(repo = "luka3117/JcPackage/zemi")
zemi::JcFA()
